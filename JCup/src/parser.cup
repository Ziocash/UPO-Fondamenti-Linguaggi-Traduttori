/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup;

import java_cup.runtime.*;
import cup.Lexer;
import cup.symboltable.*;
import ast.TypeDescriptor;
import java.io.IOException;
import java.io.FileReader;
import java.io.File;

parser code {:

 	protected Lexer lexer;
	private static final String ALPHABET = "abcdefghijklmnopqrstuvwxyz";
	private StringBuilder code;
	private StringBuilder logger;
	private static int registerIndex = 0;
	private static char[] register = ALPHABET.toCharArray();

	public Parser(Lexer lexer) {this.lexer = lexer;}

	/**
     * Returns {@code true} if the visitor found errors in visited AST.
     * 
     * @return {@code true} if has errors in AST, otherwise {@code false}.
     */
    public boolean hasErrors() {
        return !logger.toString().isEmpty();
    }

    /**
     * Returns a string representing all errors found in the AST.
     * 
     * @return a string representing all errors found in the AST.
     */
    public String getLoggerString() {
        return logger.toString();
    }

	/**
     * <p>
     * Gets a char to identify the register associated to a variable.
     * </p>
     * 
     * <p>
     * Increments automatically the register index.
     * </p>
     * 
     * @return a char that identifies the register.
     */
    private static char newRegister() {
        return register[registerIndex++];
    }

	/**
     * Inserts a space in the code stringbuilder.
     */
    private void insertSpace() {
        code.append(" ");
    }

	/**
     * Returns the trimmed code.
     * 
     * @return the trimmed code.
     */
    public String getCode() {
        return code.toString().trim();
    }

	/**
     * <p>
     * Checks if two {@link TypeDescriptor}s are compatible.
     * </p>
     * <p>
     * Return {@code true} if types are compatible, otherwise {@code false}.
     * </p>
     * 
     * @param t1 the variable type that will receive expression value.
     * @param t2 the expression type that will be assigned to variable.
     * @return {@code true} if types are compatible, otherwise {@code false}.
     */
    private boolean isCompatible(TypeDescriptor t1, TypeDescriptor t2) {
        return ((t1.equals(TypeDescriptor.FLOAT) && t2.equals(TypeDescriptor.INT)) || t1.equals(t2))
                && t1 != TypeDescriptor.ERROR && t2 != TypeDescriptor.ERROR;
    }

	private TypeDescriptor getOperationDescriptor(TypeDescriptor t1, TypeDescriptor t2) {
		if(!isCompatible(t1, t2))
			return TypeDescriptor.ERROR;
		else {
			if(t1.equals(t2))
				return t1;
			else if(t2.equals(TypeDescriptor.INT))
				return TypeDescriptor.FLOAT;
		}
		return TypeDescriptor.ERROR;
	}

:}

/* define how to connect to the scanner! */
init with {:
  SymbolTable.init();
  code = new StringBuilder();
  logger = new StringBuilder();
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("C:\\Users\\Simone Gattini\\source\\repos\\UPO-Fondamenti-Linguaggi-Traduttori\\JCup\\data\\input.txt");
  FileReader reader = null;
  try {
    reader = new FileReader(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,reader);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal 			SEMI, DIVIDE, TIMES, PLUS, MINUS, ASSIGN; /* Operations */
terminal 			TYINT, TYFLOAT, PRINT; /* Types */
terminal String     ID, INT, FLOAT; /* Values */

/* Non terminals */
non terminal TypeDescriptor Prg, DSs, Dcl, Stm, Exp, Val;

/* Precedences */
precedence right	PLUS, MINUS;
precedence right   	TIMES, DIVIDE;

/* The grammar rules */
Prg	::=  DSs: dss {:RESULT = dss; :};
DSs ::= Dcl : dcl DSs	{:RESULT = dcl; :}
		| Stm : stm DSs 	{:RESULT = stm;:}
		|					{: /*DO NOTHING*/:}
		;
		
Dcl ::= TYFLOAT ID : id SEMI	{:if(SymbolTable.lookup(id) != null){
										RESULT = TypeDescriptor.ERROR;
										logger.append(
                    String.format("Declaration: variable \'%s\' already declared.%n", id));
									}else{
										SymbolTable.enter(id, new Attributes(TypeDescriptor.FLOAT));
										RESULT = TypeDescriptor.FLOAT;
										SymbolTable.lookup(id).setRegister(newRegister());
									}
								:}
		| TYINT ID : id SEMI	{:if(SymbolTable.lookup(id) != null){
										RESULT = TypeDescriptor.ERROR;
															logger.append(
                    String.format("Declaration: variable \'%s\' already declared.%n", id));
									}else{
										SymbolTable.enter(id, new Attributes(TypeDescriptor.INT));
										RESULT = TypeDescriptor.INT;
										SymbolTable.lookup(id).setRegister(newRegister());
									}
								:}
		;

Stm ::= ID : id ASSIGN Exp : e SEMI		{:
																		if (SymbolTable.lookup(id) == null) {
            RESULT = TypeDescriptor.ERROR;
            logger.append(String.format("Assignment: Cannot assign \'%s\' type to \'%s\' type.%n",
                    e, SymbolTable.lookup(id).getType()));
        } else {
            if (isCompatible(SymbolTable.lookup(id).getType(), e)) {
				RESULT = SymbolTable.lookup(id).getType();
				char s = SymbolTable.lookup(id).getRegister();
				code.append("s" + s);
				insertSpace();
				code.append("0 k");
				insertSpace();
            } else {
				logger.append(String.format(
                            "BinaryOperation: Expected type FLOAT and INT for expressions, but was \'%s\' and \'%s\'.%n",
                            SymbolTable.lookup(id).getType(), e));
                    RESULT = TypeDescriptor.ERROR;
            }
        }
										:}
		| PRINT ID : id SEMI	{: 
		
								if (SymbolTable.lookup(id) == null) {
												logger.append(String.format("Variable: variable \'%s\' is not declared.%n", id));
												RESULT = TypeDescriptor.ERROR;
											} else {
												code.append("l" + SymbolTable.lookup(id).getRegister() + " p P ");
												RESULT = SymbolTable.lookup(id).getType();
											}
											:}
		;	

Exp ::= Exp : e1 PLUS Exp : e2	{: if(!isCompatible(e1, e2)){
										RESULT = TypeDescriptor.ERROR;
										logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
									} else {
										if(e1.equals(TypeDescriptor.INT)){
											RESULT = e1;
											code.append("+ ");
										} else {
											RESULT = TypeDescriptor.FLOAT;
											code.append("5 k ");
											code.append("+ ");
										}
									}

								:}
		| Exp : e1 MINUS Exp : e2	{: if(e1.equals(TypeDescriptor.ERROR) || e2.equals(TypeDescriptor.ERROR)){
										RESULT = TypeDescriptor.ERROR;
										logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
									}else if(e1 == e2){
										RESULT = e1;
										code.append("-");
										insertSpace();
									}else{
										if(e1 == TypeDescriptor.INT){
											logger.append(String.format(
                            "BinaryOperation: Expected type FLOAT and INT for expressions, but was \'%s\' and \'%s\'.%n",
                            e1, e2));
											RESULT = TypeDescriptor.ERROR;
										}else{
											RESULT = TypeDescriptor.FLOAT;
											code.append("5 k");
											insertSpace();
											code.append("-");
											insertSpace();
										}
									}

								:}
		| Exp : e1 DIVIDE Exp : e2 	{: if(e1.equals(TypeDescriptor.ERROR) || e2.equals(TypeDescriptor.ERROR)){
										RESULT = TypeDescriptor.ERROR;
										logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
									}else if(e1 == e2){
										RESULT = e1;
										code.append("/");
										insertSpace();
									}else{
										if(e1 == TypeDescriptor.INT){
											logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
											RESULT = TypeDescriptor.ERROR;
										}else{
											RESULT = TypeDescriptor.FLOAT;
											code.append("5 k");
											insertSpace();
											code.append("/");
											insertSpace();
										}
									}

								:}
		| Exp : e1 TIMES Exp : e2 	{: if(e1.equals(TypeDescriptor.ERROR) || e2.equals(TypeDescriptor.ERROR)){
										RESULT = TypeDescriptor.ERROR;
										logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
									}else if(e1 == e2){
										RESULT = e1;
										code.append("*");
										insertSpace();
									}else{
										if(e1 == TypeDescriptor.INT){
											logger.append(String.format(
                            "BinaryOperation: Incompatible types: \'%s\' and \'%s\'.%n",
                            e1, e2));
											RESULT = TypeDescriptor.ERROR;
										}else{
											RESULT = TypeDescriptor.FLOAT;
											code.append("5 k");
											insertSpace();
											code.append("*");
											insertSpace();
										}
									}
								:}
		| Val : v	{:RESULT = v;:}
		;
		
Val ::= INT : i 	{:	RESULT = TypeDescriptor.INT;
				  		code.append(i); insertSpace(); :}
		| FLOAT : f 	{:	RESULT = TypeDescriptor.FLOAT;
					  		code.append(f);insertSpace(); :}
		| ID : id 	{:	if(SymbolTable.lookup(id) == null){
			   				RESULT = TypeDescriptor.ERROR;
							logger.append(String.format("Variable: variable \'%s\' is not declared.%n", id));
			  			} else RESULT = SymbolTable.lookup(id).getType();
						code.append("l" + SymbolTable.lookup(id).getRegister());
						insertSpace();
				:}
		;